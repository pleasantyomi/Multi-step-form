"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walkExpression = exports.applyUpdate = exports.tokenizePath = exports.clone = void 0;
const query_1 = require("../../query");
const util_1 = require("../../util");
const clone = (mode, val) => {
    switch (mode) {
        case "deep":
            return (0, util_1.cloneDeep)(val);
        case "structured":
            return structuredClone ? structuredClone(val) : (0, util_1.cloneDeep)(val);
        default:
            return val;
    }
};
exports.clone = clone;
const FILTER_IDENT_RE = /^[a-z]+[a-zA-Z0-9]*$/;
/**
 * Tokening a selector path to extract parts for the root, arrayFilter, and child
 * @param path The path to tokenize
 * @returns {parent:string,elem:string,child:string}
 */
function tokenizePath(path) {
    if (!path.includes(".$")) {
        return [{ parent: path }, []];
    }
    const begin = path.indexOf(".$");
    const end = path.indexOf("]");
    const parent = path.substring(0, begin);
    // using "$" wildcard to represent every element.
    const child = path.substring(begin + 3, end);
    (0, util_1.assert)(child === "" || FILTER_IDENT_RE.test(child), "The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters.");
    const rest = path.substring(end + 2);
    const [next, elems] = rest ? tokenizePath(rest) : [];
    return [
        { parent, child: child || "$", next },
        [child, ...(elems || [])].filter(Boolean)
    ];
}
exports.tokenizePath = tokenizePath;
/**
 * Applies an update function to a value to produce a new value to modify an object in-place.
 * @param o The object or array to modify.
 * @param n The path node of the update selector.
 * @param q Map of positional identifiers to queries for filtering.
 * @param f The update function which accepts containver value and key.
 */
const applyUpdate = (o, n, q, f, opts) => {
    const { parent, child: c, next } = n;
    if (!c) {
        // wrapper to collect status
        let b = false;
        const g = (u, k) => (b = Boolean(f(u, k)) || b);
        (0, util_1.walk)(o, parent, g, opts);
        return b;
    }
    const t = (0, util_1.resolve)(o, parent);
    // do nothing if we don't get correct type.
    if (!(0, util_1.isArray)(t))
        return false;
    // apply update to matching items.
    return t
        .map((e, i) => {
        // filter if applicable.
        if (q[c] && !q[c].test({ [c]: e }))
            return false;
        // apply update.
        return next ? (0, exports.applyUpdate)(e, next, q, f) : f(t, i);
    })
        .some(Boolean);
};
exports.applyUpdate = applyUpdate;
function walkExpression(expr, arrayFilter, options, callback) {
    const res = [];
    for (const [selector, val] of Object.entries(expr)) {
        const [node, vars] = tokenizePath(selector);
        if (!vars.length) {
            if (callback(val, node, {}))
                res.push(node.parent);
        }
        else {
            // extract conditions for each identifier
            const conditions = {};
            arrayFilter.forEach(o => {
                Object.keys(o).forEach(k => {
                    vars.forEach(w => {
                        if (k === w || k.startsWith(w + ".")) {
                            conditions[w] = conditions[w] || {};
                            Object.assign(conditions[w], { [k]: o[k] });
                        }
                    });
                });
            });
            // create queries for each identifier
            const queries = {};
            for (const [k, condition] of Object.entries(conditions)) {
                queries[k] = new query_1.Query(condition, options.queryOptions);
            }
            if (callback(val, node, queries))
                res.push(node.parent);
        }
    }
    return res;
}
exports.walkExpression = walkExpression;
